# Default ROOTFS if not specified
define(ROOTFS, "${PROJECT_ROOT}/output/images/rootfs.ext2")

# Image layout
# +-------------------------+
# | MBR                     |
# +-------------------------+
# | FSBL 1                  |
# | for tf-a-*.stm32        |
# +-------------------------+
# | FSBL 2                  |
# | for tf-a-*.stm32        |
# +-------------------------+
# | SSBL for u-boot.stm32   |
# +-------------------------+
# | Rootfs partition (EXT4) |
# | bootable                |
# +-------------------------+

# The First Stage Boot Loader 1
define(FSBL1_PART_OFFSET, 34)
define(FSBL1_PART_COUNT, 512) # 512 * 512 / 1024 = 256 KiB

# The First Stage Boot Loader 2
define(FSBL2_PART_OFFSET, 546)
define(FSBL2_PART_COUNT, 512) # 512 * 512 / 1024 = 256 KiB

# The Second Stage Boot Loader 2
define(SSBL_PART_OFFSET, 1058)
define(SSBL_PART_COUNT, 4096) # 4096 * 512 / 1024 / 1024 = 2 MiB

# Let the rootfs have room to grow up to 128 MiB (256K 512-byte blocks)
define(ROOTFS_PART_OFFSET, 5154)
define(ROOTFS_PART_COUNT, 262144) # 262144 * 512 / 1024 / 1024 = 128 MiB

# Firmware metadata
meta-product = "Image for the ODYSSEY_STM32MP157C"
meta-description = "This image boots to Linux."
meta-version = "0.1"
meta-platform = "odyssey_stm32mp157c"
meta-architecture = "arm"
meta-author = "Tombo Works"

# File resources are listed in the order that they are included in the .fw file
# This is important, since this is the order that they're written on a firmware
# update due to the event driven nature of the update system.
file-resource tf-a-stm32mp157c-odyssey.stm32.fsbl1 {
    host-path = "${PROJECT_ROOT}/output/images/tf-a-stm32mp157c-odyssey.stm32"
}
file-resource tf-a-stm32mp157c-odyssey.stm32.fsbl2 {
    host-path = "${PROJECT_ROOT}/output/images/tf-a-stm32mp157c-odyssey.stm32"
}
file-resource u-boot.stm32 {
    host-path = "${PROJECT_ROOT}/output/images/u-boot.stm32"
}
file-resource rootfs.img {
    host-path = ${ROOTFS}

    # Error out if the rootfs size exceeds the partition size
    assert-size-lte = ${ROOTFS_PART_COUNT}
}

gpt gpt {
    # UUID for the entire disk
    guid = 691f1be3-ec37-4dd2-b695-fe9901a93d63 # generated by uuidgen

    partition 0 {
        block-offset = ${FSBL1_PART_OFFSET}
        block-count = ${FSBL1_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4 # Linux filesystem type UUID
        guid = 9ecd363c-6af5-4648-b975-5b4cebef0f68 # generated by uuidgen
        name = "fsbl1"
    }
    partition 1 {
        block-offset = ${FSBL2_PART_OFFSET}
        block-count = ${FSBL2_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4 # Linux filesystem type UUID
        guid = f13c7240-fcdc-4b84-aecc-fd57dc6c27ed # generated by uuidgen
        name = "fsbl2"
    }
    partition 2 {
        block-offset = ${SSBL_PART_OFFSET}
        block-count = ${SSBL_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4 # Linux filesystem type UUID
        guid = 3b122046-ac67-4174-8ee8-0d2e9842fad4 # generated by uuidgen
        name = "ssbl"
    }
    partition 3 {
        block-offset = ${ROOTFS_PART_OFFSET}
        block-count = ${ROOTFS_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4 # Linux filesystem type UUID
        guid = 5c58aef9-cc84-4d5e-a11f-4d18571ee5bb # generated by uuidgen
        name = "rootfs"
        boot = true
    }
}

# This firmware task writes everything to the destination media
task complete {
    # Only match if not mounted
    require-unmounted-destination = true

    # Everything that gets written can be verified on the fly.
    # This speeds things up, since we don't care about detecting
    # errors before data gets written.
    verify-on-the-fly = true

    on-init { gpt_write(gpt) }

    on-resource tf-a-stm32mp157c-odyssey.stm32.fsbl1 { raw_write(${FSBL1_PART_OFFSET}) }
    on-resource tf-a-stm32mp157c-odyssey.stm32.fsbl2 { raw_write(${FSBL2_PART_OFFSET}) }

    on-resource u-boot.stm32 { raw_write(${SSBL_PART_OFFSET}) }

    on-resource rootfs.img { raw_write(${ROOTFS_PART_OFFSET}) }

    on-finish { }
}
