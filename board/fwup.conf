# Default ROOTFS if not specified
define(ROOTFS, "${PROJECT_ROOT}/output/images/rootfs.ext2")
define(UNAME_R, "5.5.19-armv7-lpae-x27")

# Image layout
# +-------------------------+
# | MBR                     |
# +-------------------------+
# | FSBL 1                  |
# | for u-boot-spl.stm32    |
# +-------------------------+
# | FSBL 2                  |
# | for u-boot-spl.stm32    |
# +-------------------------+
# | SSBL for u-boot.img     |
# +-------------------------+
# | BOOT partition (FAT16)  |
# | uEnv.txt                |
# | *.dtb                   |
# +-------------------------+
# | Rootfs partition (EXT4) |
# +-------------------------+

# The First Stage Boot Loader 1
define(FSBL1_PART_OFFSET, 34)
define(FSBL1_PART_COUNT, 512) # 512 * 512 / 1024 = 256 KiB

# The First Stage Boot Loader 2
define(FSBL2_PART_OFFSET, 546)
define(FSBL2_PART_COUNT, 512) # 512 * 512 / 1024 = 256 KiB

# The Second Stage Boot Loader 2
define(SSBL_PART_OFFSET, 1058)
define(SSBL_PART_COUNT, 4096) # 4096 * 512 / 1024 / 1024 = 2 MiB

# The boot partition has room for a uEnv.txt. (Only about 1 MB)
define(BOOT_PART_OFFSET, 5154)
define(BOOT_PART_COUNT, 131072) # 131072 * 512 / 1024 / 1024 = 64 MiB

# Let the rootfs have room to grow up to 128 MiB (256K 512-byte blocks)
define(ROOTFS_PART_OFFSET, 136226)
define(ROOTFS_PART_COUNT, 262144) # 262144 * 512 / 1024 / 1024 = 128 MiB

# Firmware metadata
meta-product = "Image for the ODYSSEY_STM32MP157C"
meta-description = "This image boots to Linux."
meta-version = "0.1"
meta-platform = "odyssey_stm32mp157c"
meta-architecture = "arm"
meta-author = "Tombo Works"

# File resources are listed in the order that they are included in the .fw file
# This is important, since this is the order that they're written on a firmware
# update due to the event driven nature of the update system.
file-resource u-boot-spl.stm32 {
    host-path = "${BR2_EXTERNAL_ODYSSEY_STM32MP157C_PATH}/board/u-boot/u-boot-spl.stm32"
}
file-resource u-boot.img {
    host-path = "${BR2_EXTERNAL_ODYSSEY_STM32MP157C_PATH}/board/u-boot/u-boot.img"
}
file-resource uEnv.txt {
    host-path = "${BR2_EXTERNAL_ODYSSEY_STM32MP157C_PATH}/board/u-boot/uEnv.txt"
}
file-resource stm32mp157c-seeed-npi.dtb {
    host-path = "${BR2_EXTERNAL_ODYSSEY_STM32MP157C_PATH}/board/stm32mp157c-seeed-npi.dtb"
}
file-resource rootfs.img {
    host-path = ${ROOTFS}

    # Error out if the rootfs size exceeds the partition size
    assert-size-lte = ${ROOTFS_PART_COUNT}
}

mbr mbr {
    partition 3 {
        block-offset = ${BOOT_PART_OFFSET}
        block-count = ${BOOT_PART_COUNT}
        type = 0x06 # FAT16
        boot = true
    }
    partition 4 {
        block-offset = ${ROOTFS_PART_OFFSET}
        block-count = ${ROOTFS_PART_COUNT}
        type = 0x83 # Linux
    }
}

# This firmware task writes everything to the destination media
task complete {
    # Only match if not mounted
    require-unmounted-destination = true

    # Everything that gets written can be verified on the fly.
    # This speeds things up, since we don't care about detecting
    # errors before data gets written.
    verify-on-the-fly = true

    on-init {
        mbr_write(mbr)

        fat_mkfs(${BOOT_PART_OFFSET}, ${BOOT_PART_COUNT})
        fat_setlabel(${BOOT_PART_OFFSET}, "BOOT")

        fat_mkdir(${BOOT_PART_OFFSET}, "dtbs/${UNAME_R}")
    }

    on-resource u-boot-spl.stm32 { raw_write(${FSBL1_PART_OFFSET}) }

    on-resource u-boot-spl.stm32 { raw_write(${FSBL2_PART_OFFSET}) }

    on-resource u-boot.img { raw_write(${SSBL_PART_OFFSET}) }

    on-resource uEnv.txt { fat_write(${BOOT_PART_OFFSET}, "uEnv.txt") }
    on-resource stm32mp157c-seeed-npi.dtb {
        fat_write(${BOOT_PART_OFFSET}, "dtbs/${UNAME_R}/stm32mp157c-seeed-npi.dtb")
    }

    on-resource rootfs.img {
        # write to the first rootfs partition
        raw_write(${ROOTFS_PART_OFFSET})
    }

    on-finish {
    }
}
